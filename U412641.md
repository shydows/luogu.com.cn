https://www.luogu.com.cn/problem/U412641

# 任务调度

## 题目背景

**时间限制：** 3 秒

**空间限制：** 512 MB

## 题目描述

任务调度是计算机系统中一项重要的工作。今天你的任务，就是模拟一个计算机系统模型的任务调度过程，并给出相应操作的执行结果。

在这个模型中，不同任务按照一定顺序到来，等待被执行。任务处理机制需要维护任务的等待情况，并在相应的时机选择相应的任务进行执行。

不同的任务之间以编号进行区分，为方便起见，按照任务到来的顺序，由先到后编号为 $1,2,3,...$ 。每个任务都拥有一个重要程度 $a_i$ ，所有任务的重要程度两两不同。

在一般情况下，处理任务应当按照任务到来的先后顺序依次处理，也就是说任务等待应当形成一个队列。但考虑到不同任务的重要程度不同，这一原则可能被打破。具体而言，有如下几种操作：

- $1\text{ }a_i$ : 一个新的任务到来，其编号为先前出现过的最大任务编号 $+1$ ，其重要程度为 $a_i$，在任务等待队列中被安排至队列末尾。考虑到计算机内存限制，同一时刻正在等待的任务数量不能超过 $m$ ，因此如果当前已经有 $m$ 个任务在等待，则这一操作将出现错误。
- $2\text{ }a_i\text{ }x_i$ : 一个新的任务到来，其编号为先前出现过的最大任务编号 $+1$ ，其重要程度为 $a_i$，在任务等待队列中被安排至任务编号为 $x_i$ 的任务前面并紧挨任务 $x_i$ 的位置。如果当前已有 $m$ 个任务在等待，或任务 $x_i$ 当前不在等待队列中，这一操作将出现错误。
- $3$ : 任务处理机制将处理当前排在等待队列队首的任务，并将其从等待队列中移除。若当前等待队列为空，这一操作将出现错误。
- $4$ : 任务处理机制将处理当前等待队列中重要程度最大的任务，并将其从等待队列中移除。若当前等待队列为空，这一操作将出现错误。

除上述提到的错误情况外，操作均可以成功执行。

最开始，任务等待队列为空，接下来你需要处理 $n$ 个操作，每个操作形如上述几种之一。对于每个操作，你需要正确判断是否会出现错误，如果出现错误，需要输出一个 `ERR` ，并不予以执行（但对于操作 $1$ 和 $2$ 而言，仍会占用一个新的任务编号）；如果可以成功执行，则需要输出一个正整数，表示这次操作涉及到的任务编号，在操作 $1$ 和 $2$ 中表示新到来的任务编号，操作 $3$ 和 $4$ 中表示被处理的任务编号。

## 输入格式

从标准输入读入数据。

输入的第一行包含两个正整数 $n, m$ ，分别表示需要执行的操作个数和队伍的最大容量。

接下来 $n$ 行，每行按上述格式描述一个操作。

## 输出格式

输出到标准输出。

输出 $n$ 行，每行表示对应操作执行的结果，格式如上所述。

## 样例 #1

### 样例输入 #1

```
12 3
1 2
1 6
2 1 2
2 7 3
1 5
3
3
1 8
2 4 3
4
4
4
```

### 样例输出 #1

```
1
2
3
ERR
ERR
1
3
6
ERR
6
2
ERR
```

## 提示

### 样例 1 解释

第 $4, 5$ 次操作均因等待队列已满而出现错误，第 $9$ 次操作因 $x_i$ 不存在于等待队列中而出现错误，第 $12$ 次操作因等待队列为空而出现错误。

### 子任务

对于全部的数据，保证：$1 \le n, m \le 5 \times 10^5,1 \le a_i, x_i \le n$ ，所有 $a_i$ 两两不同。

| 测试点编号  | $n \le$ | $m \le$ | 特殊条件 |
| :----:  | :-----: | :-----: | :------: |
|   $1\sim 2$     |  $200$   |   $200$   |    无    |
|   $3\sim 5$    | $3000$  |   $500$   |    无    |
|   $6\sim 7$     |  $5 \times 10^5$   | $100$  |    无    |
|   $8\sim 10$     | $5 \times 10^5$  | $5 \times 10^5$  |    没有操作 $2$ 和 $4$     |
|   $11\sim 13$     | $5 \times 10^5$  | $5 \times 10^5$  |    没有操作 $4$    |
|   $14\sim 16$     | $5 \times 10^5$  | $5 \times 10^5$  |    没有操作 $2$   |
|   $17\sim 20$     | $5 \times 10^5$  | $5 \times 10^5$  |    无    |

****

```cpp
#include<bits/stdc++.h>
using namespace std;

int rd() {
    int k = 0, f = 1;
    char c = getchar();
    while (c < '0' || c > '9') {
        if (c == '-')
            f = 0;
        c = getchar();
    }
    while (c >= '0' && c <= '9') {
        k = (k << 1) + (k << 3) + (c ^ 48);
        c = getchar();
    }
    return f ? k : -k;
}
void wr(int x) {
    if (x < 0)
        putchar('-'), x = -x;
    if (x > 9)
        wr(x / 10);
    putchar((x % 10) ^ '0');
}

const int N = 514114;
const int left_tail = N - 2, right_tail = N - 1;
// list size, mission number, size limit
int pre[N], nxt[N], val[N], sz, no, limit;
// <-importance, number>
set<pair<int, int>> s;

void init(int lim) {
    nxt[left_tail] = right_tail, pre[right_tail] = left_tail, limit = lim;
}

// insert at pos's right, assume mission doesn't exist
// mission number = num (1\le num \le n), importance = a (1\le a \le n)
void insert(int pos, int num, int a) {
    val[num] = a, pre[num] = pos, nxt[num] = nxt[pos];
    pre[nxt[pos]] = num, nxt[pos] = num;
    s.insert(make_pair(-a, num)), ++sz;
}

// remove mission by num, assume mission exists.
void remove(int num) {
    pre[nxt[num]] = pre[num], nxt[pre[num]] = nxt[num];
    s.erase(s.find(make_pair(-val[num], num)));
    pre[num] = nxt[num] = val[num] = 0, --sz;
}

// operation 1 : insert at back
void op_1(int a) {
    ++no; // new number whether success or not.
    if (sz == limit)
        return (void)puts("ERR");
    insert(pre[right_tail], no, a);
    wr(no), putchar('\n'); // insert success, print number.
}

// operation 2 : insert at x's left
void op_2(int a, int x) {
    ++no;
    if (sz == limit || !val[x])
        return (void)puts("ERR");
    insert(pre[x], no, a);
    wr(no), putchar('\n');
}

// operation 3 : pop left
void op_3() {
    if (!sz)
        return (void)puts("ERR");
    wr(nxt[left_tail]), putchar('\n');
    remove(nxt[left_tail]);
}

// operation 4 : pop biggest importance
void op_4() {
    if (!sz)
        return (void)puts("ERR");
    wr(s.begin()->second), putchar('\n');
    remove(s.begin()->second);
}

void print_list() {
    int cnt = 0;
    for (int i = nxt[left_tail]; i ^ right_tail; i = nxt[i])
        wr(i), putchar(' '), wr(val[i]), putchar('\n'), ++cnt;
    putchar('\n');
    assert(!(cnt ^ sz));
}

int main() {
    int n = rd(), m = rd();
    int op = 0, a = 0, x = 0;
    init(m);
    while (n--) {
        op = rd();
        switch (op) {
        case 1:
            a = rd(), op_1(a);
            break;
        case 2:
            a = rd(), x = rd(), op_2(a, x);
            break;
        case 3:
            op_3();
            break;
        case 4:
            op_4();
            break;
        default:
            break;
        }
    }
}
```