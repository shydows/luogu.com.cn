https://www.luogu.com.cn/problem/U281238

# 命令行选项

## 题目背景

2014 年清华大学考研机试第三题

第一次 CCF 认证[第三题](http://118.190.20.162/view.page?gpid=T8)

## 题目描述

请你写一个命令行分析程序，用以分析给定的命令行里包含哪些选项。每个命令行由若干个字符串组成，它们之间恰好由一个空格分隔。这些字符串中的第一个为该命令行工具的名字，由小写字母组成，你的程序不用对它进行处理。在工具名字之后可能会包含若干选项，然后可能会包含一些不是选项的参数

选项有两类：带参数的选项和不带参数的选项。一个合法的无参数选项的形式是一个减号后面跟单个小写字母，如 `-a` 或 `-b`。而带参数选项则由两个由空格分隔的字符串构成，前者的格式要求与无参数选项相同，后者则是该选项的参数，是由小写字母，数字和减号组成的非空字符串

该命令行工具的作者提供给你一个格式字符串以指定他的命令行工具需要接受哪些选项。这个字符串由若干小写字母和冒号组成，其中的每个小写字母表示一个该程序接受的选项。如果该小写字母后面紧跟了一个冒号，它就表示一个带参数的选项，否则则为不带参数的选项。例如， `ab:m:` 表示该程序接受三种选项，即 `-a`（不带参数），`-b`（带参数）， 以及 `-m`（带参数）

命令行工具的作者准备了若干条命令行用以测试你的程序。对于每个命令行，你的工具应当一直向后分析。当你的工具遇到某个字符串既不是合法的选项，又不是某个合法选项的参数时，分析就停止。命令行剩余的未分析部分不构成该命令的选项，因此你的程序应当忽略它们

## 输入格式

输入的第一行是一个格式字符串，它至少包含一个字符，且长度不超过 52。格式字符串只包含小写字母和冒号，保证每个小写字母至多出现一次，不会有两个相邻的冒号，也不会以冒号开头

输入的第二行是一个正整数 $N~(1 \le N \le 20)$，表示你需要处理的命令行的个数

接下来有 $N$ 行，每行是一个待处理的命令行，它包括不超过 256 个字符。该命令行一定是若干个由单个空格分隔的字符串构成，每个字符串里只包含小写字母，数字和减号

## 输出格式

输出有 $N$ 行。其中第 $i$ 行以 `Case i:` 开始，然后应当有恰好一个空格，然后应当按照字母升序输出该命令行中用到的所有选项的名称，对于带参数的选项，在输出它的名称之后还要输出它的参数。如果一个选项在命令行中出现了多次，只输出一次。如果一个带参数的选项在命令行中出现了多次，只输出最后一次出现时所带的参数

## 样例 #1

### 样例输入 #1

```
albw:x
4
ls -a -l -a documents -b
ls
ls -w 10 -x -w 15
ls -a -b -c -d -e -l
```

### 样例输出 #1

```
Case 1: -a -l
Case 2:
Case 3: -w 15 -x
Case 4: -a -b
```
```cpp
#include <iostream>
#include <string.h>
using namespace std;
const int N = 'z' + 1, M = 260;

char s[M], ans[N][M];
bool op1[N], op2[N], vis1[N], vis2[N];
void process() {
    memset(ans, 0, sizeof ans), memset(vis1, 0, sizeof vis1), memset(vis2, 0, sizeof vis2);
    for (int i = 0, op = 0, idx = 0, valid = false; s[i]; valid = valid || s[i] == ' ', i++)
        // 跳过开头的命令
        if (!valid)
            continue;
    // 遇到空格必是参数读完了
        else if (s[i] == ' ')
            ans[op][idx] = 0,//char赋值为0就是断了，后面判断也就知道后面没有了
            vis2[op] = true, op = idx = 0;
    // 读入参数过程
        else if (op)
            ans[op][idx++] = s[i];
    // 读入合法的命令行选项
    // islower(s[i + 1])判断是否是小写字母
        else if (s[i] == '-' && islower(s[i + 1]) && s[i + 2] == ' ' && (op1[s[i + 1]] || op2[s[i + 1]])) {
            // 不带参数
            if (op1[s[i + 1]])
                vis1[s[i + 1]] = true;
            // 带参数
            else
                op = s[i + 1];
            // 跳过这个参数
            i += 2;
        }
    // 非法字符
        else
            break;

    for (char c = 'a'; c <= 'z'; c++)
        if (vis1[c])
            printf(" -%c", c);
        else if (vis2[c])
            printf(" -%c %s", c, ans[c]);
    printf("\n");
}

int main() {
    scanf("%s", s);
    for (int i = 0; s[i]; i++)
        if (s[i + 1] == ':')
            op2[s[i++]] = true;
        else
            op1[s[i]] = true;

    int n;
    // 记得跳过换行符
    scanf("%d\n", &n);
    for (int i = 1; i <= n; i++) {
        int idx = 0;
        for (char c; c = getchar(), c && c != '\n';)
            s[idx++] = c;
        // 结尾处插入一个空格，便于后续处理
        s[idx++] = ' ', s[idx] = 0;
        printf("Case %d:", i), process();
    }
}
```